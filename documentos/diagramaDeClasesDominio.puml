@startuml diagramaDeClasesDominio.
!theme reddress-darkblue

' -----------------------------------------

class PersonaHumana {
 - contacto: Contacto
 - direccion: Direccion
 - nombre: String
 - apellido: String
 - documento: Documento
 - fechaNacimiento: LocalDate
 - tarjeta: Tarjeta
 - ofertasCanjeadas: List<OfertaCanjeada>
 - contribucionesElegidas: Set<FormasContribucionHumanas>
 - contribuciones: Set<Contribucion>
 - ofertasCanjeadas: Set<OfertaCanjeada>
 - formulario: List<Respuesta>

 + puntosGastados(): float
 + calcularPuntajeNeto(): float
 + agregarContribucion(contribucion: Contribucion): void
 + agregarOfertaCanjeada(ofertaCanjeada: OfertaCanjeada): void
 + usarTarjeta(heladera: Heladera): void
 + asignarTarjeta(tarjeta: Tarjeta): void
 + serNotificadoPor(mensaje: Mensaje): void
}

PersonaHumana --> " * " Contribucion
PersonaHumana --> Contacto
PersonaHumana --> Direccion
PersonaHumana --> Documento
PersonaHumana --> " * " FormasContribucionHumanas
PersonaHumana --> Usuario
PersonaHumana --> " * " OfertaCanjeada
PersonaHumana --> " * " Respuesta
PersonaHumana --> Tarjeta
PersonaHumana ..|> IObserverNotificacion 

' -----------------------------------------

interface IObserverNotificacion {
 + serNotificadoPor(mensaje: Mensaje): void
}

' -----------------------------------------

class Vianda {
 - fechaCaducidad: LocalDate
 - entregada: boolean
 - comida: String
 - pesoEnGramos: float
 - fechaDonacion: LocalDate
 + calcularPuntaje(): float
 + estaVencida(): boolean
}

Vianda ..|> Contribucion

' -----------------------------------------

class Heladera {
 - nombre: String
 - direccion: Direccion
 - fechaRegistro: LocalDate
 - capacidadMaximaViandas: int
 - modelo: Modelo
 - viandas: Set<Vianda>
 - estado: EstadoHeladera
 - temperaturaEsperada: float
 - historialEstados: List<CambioEstado>
 - historialTemperaturas: List<CambioTemperatura>
 - solicitudesDeApertura: List<SolicitudApertura>
 - gestorSuscripciones: GestorSuscripciones
 + ingresarViandas(viandas: List<Vianda>): void
 + quitarViandas(viandas: List<Vianda>): void
 + notificarColaborador(): void
 + calcularPuntaje(): float
 + cambiarEstado(nuevoEstado: CambioEstado): void
 - tieneTemperaturaValida(): boolean
 + cambiarTemperatura(temperatura: float): void
 - agregarTemperaturaAlHistorial(temperatura: float): void
 + estaActiva(): boolean
 + validarApertura(codigoTarjeta: String): boolean
 + agregarSolicitudApertura(solicitud: SolicitudApertura): void
 + cantidadViandas(): int
 + cantidadViandasVirtuales(): int
 + enviarAHeladeraFisicaSolicitudApertura(): void
}

Heladera --> " * " Vianda
Heladera --> Modelo
Heladera --> Direccion
Heladera ..|> Contribucion
Heladera --> EstadoHeladera
Heladera --> " * " CambioEstado
Heladera --> " * " CambioTemperatura
Heladera --> " * " SolicitudApertura
Heladera --> GestorSuscripciones

' -----------------------------------------

class ValidadorConexion {
 - umbralDesconexionEnMinutos: int
 - heladerasRepositorio: IRepositoryHeladera
 + verificarConexionHeladeras(): void
 - estaConectada(heladera: Heladera): boolean
}

ValidadorConexion ..> Heladera

note right
La falla de conexión se verificará validando la última recepción de temperatura de cada heladera con un cronjob: ValidadorConexion.
La cantidad de tiempo límite desde que se recibió la última temperatura estará parametrizada.
end note

' -----------------------------------------

class GestorSuscripciones {
   - suscripcionesPorTipo: Map<TipoSuscripcion, Suscripcion>
   /'
    suscripcionesPorTipo: {FALTAN_N_VIANDAS: [fulano, mengano], DESPERFECTO: [zultano]}
   '/ 
   + notificar(tipoEvento: TipoEvento, heladera: Heladera): void
   /'
   {
      interesados = suscripcionesPorTipo[tipoEvento]
      recorre lista y notifica
   }'/
}

GestorSuscripciones --> " * " Suscripcion
GestorSuscripciones --> " * " TipoSuscripcion
GestorSuscripciones ..> Heladera

enum TipoSuscripcion {
 FALTAN_N_VIANDAS
 DESPERFECTO
 QUEDAN_N_VIANDAS
}

class Suscripcion {
 - colaborador: Colaborador
 + notificar(heladera: Heladera): void
   /'
   if(cumpleCondicion(heladera)){
      mensaje = armarMensaje(heladera);
      this.colaborador.serNotificadoPor(mensaje);
      mensaje.registrar();
   }'/
   
 # cumpleCondicion(heladera: Heladera): void
 # armarMensaje(heladera: Heladera): String
}

Suscripcion --> Colaborador
Suscripcion ..> Heladera

class QuedanNViandas {
 - cantidadViandasDisponibles: int
 - colaborador: Colaborador
 # cumpleCondicion(heladera: Heladera): void
 # armarMensaje(heladera: Heladera): String
}

class FaltanNViandas {
 - cantidadViandasParaLlenarse: int
 - colaborador: Colaborador
 # cumpleCondicion(heladera: Heladera): void
 # armarMensaje(heladera: Heladera): String
}

class Desperfecto {
 - colaborador: Colaborador
 - aceptada: bool ? 'el colaborador debe aceptar o rechazar esta sugerencia
 + sugerirHeladeras(heladera: Heladera): List<Heladera>?
 # cumpleCondicion(heladera: Heladera): void
 # armarMensaje(heladera: Heladera): String
}

QuedanNViandas --|> Suscripcion
FaltanNViandas --|> Suscripcion
Desperfecto --|> Suscripcion

' -----------------------------------------

interface IAdapterPDF {
+ exportarAPDF(parrafos: List<String>): void
}

class AdapterPDFiText {
+ exportarAPDF(parrafos: List<String>): void
}

AdapterPDFiText ..|> IAdapterPDF

class GeneradorReportes {
 - reportes: List<Reporte>
 + generarReportes(): void
}

GeneradorReportes --> " * " Reporte

interface Reporte {
 + generarReporte(parrafos: List<String>): void
}

class CantidadDeFallasPorHeladera {
 - pdfAPI: IAdapterPDF
+ generarReporte(parrafos: List<String>): void
}

CantidadDeFallasPorHeladera ..|> Reporte
CantidadDeFallasPorHeladera --> IAdapterPDF

class MovimientoDeViandasPorHeladera {
 - pdfAPI: IAdapterPDF
 + generarReporte(parrafos: List<String>): void
}

MovimientoDeViandasPorHeladera ..|> Reporte
MovimientoDeViandasPorHeladera --> IAdapterPDF

class CantidadViandasPorColaborador {
 - pdfAPI: IAdapterPDF
 + generarReporte(parrafos: List<String>): void
}

CantidadViandasPorColaborador ..|> Reporte
CantidadViandasPorColaborador --> IAdapterPDF

' -----------------------------------------

class SolicitudApertura {
 - fecha: LocalDateTime
 - codigoTarjeta: String 
 - aperturaConcretada: boolean
 - accion: Accion
}

SolicitudApertura --> Accion

enum Accion {
 QUITAR_VIANDA
 INGRESAR_VIANDA
}

' -----------------------------------------

class CambioEstado {
 - fechaCambio: LocalDate
 - estado: EstadoHeladera
}

CambioEstado --> EstadoHeladera

note bottom
Permite trazabilidad
end note

' -----------------------------------------

class Incidente {
 - heladera: Heladera
 - fechaCambio: LocalDateTime
 - tecnico: Tecnico
 - visitas: List<Visita>
 - solucionado: bool
 - tipoIncidente: TipoIncidente
 + registrarVisita(visita: Visita): void
 + asignarTecnico(): void
 /'
 float distanciaMasCorta; Tecnico tecnico; float distanciaActual;
 for cada tecnico
   for cada tecnico.areaDeCobertura
      distanciaActual = heladera.getDireccion().getCoordenada().distanciaCon(area.getCoordenada())
      if distanciaActual < distanciaMasCorta{
         distanciaMasCorta = distanciaActual
         tecnico = tecnico

   tecnico.getMedioDeContacto().notificar(new Mensaje("heladera"+...+tipoIncidente.obtenerDescripcionIncidente()))
   '/
}

Incidente --> TipoIncidente
Incidente --> " * " Visita
Incidente ..> ServicioGeoRef
Incidente --> Tecnico

interface TipoIncidente {
 + obtenerDescripcionIncidente(): String
} 

class Visita {
 - descripcion: String
 - foto: Image
}

class Alerta {
 - incidente: Incidente
 - tipo: TipoAlerta
 + obtenerDescripcionIncidente(): String
}

Alerta ..|> TipoIncidente
Alerta --> TipoAlerta

class FallaTecnica {
 - incidente: Incidente
 - colaborador: 
 - descripcion: String
 - foto: Image
 + obtenerDescripcionIncidente(): String
}

FallaTecnica ..|> TipoIncidente

enum TipoAlerta {
 FRAUDE
 FALLA_CONEXION
 FALLA_TEMPERATURA
}

' -----------------------------------------

class ServicioGeoRef {
 - instancia: ServicioGeoRef
 - retrofit: Retrofit
 + obtenerDetallesUbicacion(latitud: double, longitud: double): Direccion
}

' -----------------------------------------

class ReceptorTemperatura {
 + messageArrived(topic: String, mqttMessage MqttMesage): void 
   /'{
      heladera = repositorioHeladeras.buscar(mqttMessage.toString());
      heladera.cambiarTemperatura(mqttMessage.temperatura());
   }'/
}

class ReceptorMovimiento {
 + messageArrived(topic: String, mqttMessage MqttMesage): void 
   /'{
      heladera = repositorioHeladeras.buscar(mqttMessage.toString());
      heladera.cambiarEstado(FRAUDE);
   }'/
}

' VERIFICAR!!!!! estan bien estas relaciones?
ReceptorMovimiento ..> Heladera
ReceptorTemperatura ..> Heladera

' -----------------------------------------

class CambioTemperatura {
 - fecha: LocalDateTime
 - temperaturaCelsius: float
}

' -----------------------------------------

class CargaMasivaColaboraciones {
 - personaHumanaRepo: IRepositorioPersonaHumana
 - documentoRepo: IRepositorioDocumento
 + cargarColaboraciones(dataCSV: File): void
}

CargaMasivaColaboraciones ..> AdapterMail

' -----------------------------------------

class Modelo {
 - modelo: String
 - temperaturaMinima: float
 - temperaturaMaxima: float
}

' -----------------------------------------

class DistribucionVianda {
 - heladeraOrigen: Heladera
 - heladeraDestino: Heladera
 - cantidadViandas: int
 - motivo: String
 - fecha: LocalDate
 - terminada: bool
 - viandasAMover: List<Vianda>
 + quitarViandasDeOrigen(viandasAQuitar: List<Vianda>): void
 /'{
      origen.quitarViandas(viandasAQuitar)
      viandasAMover = viandasAQuitar
   }'/
 + ponerViandasEnDestino():void
 /' {
      destino.meterViandas(viandasAMover)
   }'/
 + distribuir(viandas: List<Vianda>): void
 + calcularPuntaje(): float
}

DistribucionVianda --> Heladera
DistribucionVianda --> Heladera
DistribucionVianda ..> " * " Vianda
DistribucionVianda ..|> Contribucion

' -----------------------------------------

interface Contribucion {
 + calcularPuntaje(): float
}

note bottom
Las contribuciones comparten la funcionalidad de sumar puntos, por lo
tanto, decidimos que implementen una interfaz de contribución y de esta
forma agrupar las contribuciones, permitiendo trazabilidad.
end note

' -----------------------------------------

class DonacionDinero {
 - monto: float
 - frecuencia: Integer
 - unidadFrecuencia: String
 - fecha: LocalDate
 + calcularPuntaje(): float
}

DonacionDinero ..|> Contribucion

note bottom
unidadFrecuencia podría tener los valores:
 - Semanal
 - Mensual
 - Anual
end note

' -----------------------------------------

class Oferta {
 - nombre: String
 - cantidadPuntosNecesarios: float
 - imagen: ???
 - rubro: Rubro
 - organizacion: PersonaJuridica
 + canjear(): void
}

Oferta --> PersonaJuridica
Oferta --> Rubro

class OfertaCanjeada {
 - oferta: Oferta
 - fechaCanje: LocalDateTime
}

OfertaCanjeada --> Oferta


' -----------------------------------------

class Rubro {
 - nombre: String
}

' -----------------------------------------

class Documento {
 - tipo: TipoDocumento
 - documento: String
}

Documento --> TipoDocumento

' -----------------------------------------

interface MedioDeContacto {
 + enviar(mensaje: Mensaje)
}

MedioDeContacto ..> Mensaje

' -----------------------------------------

class WhatsApp {
 - numero: String
 + enviar(mensaje: Mensaje)
}

WhatsApp ..|> MedioDeContacto

' -----------------------------------------

class Telefono {
 - numero: String
 + enviar(mensaje: Mensaje)
}

Telefono ..|> MedioDeContacto

' -----------------------------------------

class Mail {
 - correo: String
 - adapterMail: AdapterMail
 + enviar(mensaje: Mensaje)
}

Mail ..|> MedioDeContacto
Mail -> AdapterMail

' -----------------------------------------

interface AdapterMail {
 + enviar(mensaje: Mensaje, correo: String)
}
note bottom
Utilizamos un adapter para tener mayor testeabilidad,
mantenibilidad y un menor acoplamiento
end note

' -----------------------------------------

class AdapterConcretoPuntos {
 - servicioRecomendacionPunto: RecomendacionPuntosServicio
 + recomendacion(latitud: String, longitud: String, radio: float): List<Coordenada>
}

note top
Por mantenibilidad, cohesion y testeabilidad utilizamos el patron
adapter.
end note

AdapterConcretoPuntos ..|> AdapterRecomendacionPuntosHeladera
AdapterConcretoPuntos --> RecomendacionPuntosServicio

' -----------------------------------------

class RecomendacionPuntosServicio {
 - urlAPI: String
 - retrofit: Retrofit
 + listadoPuntosRecomendados(float radio, String latitud, String longitud): ListadoPuntosRecomendados
}

RecomendacionPuntosServicio ..> ListadoPuntosRecomendados

' -----------------------------------------

class ListadoPuntosRecomendados {
 - parametro: Area
 + puntos: List<Coordenada>
}

ListadoPuntosRecomendados --> Area
ListadoPuntosRecomendados --> " * " Coordenada

' -----------------------------------------

class RecomendacionDePuntos {
 - adapterPuntos: AdapterRecomendacionPuntosHeladera
 + recomendacion(latitud: String, longitud: String, radio: float): List<Coordenada>
}

RecomendacionDePuntos --> AdapterRecomendacionPuntosHeladera

' -----------------------------------------

class MailSender {
 + enviar(mensaje: Mensaje, destinatario: String)
}

MailSender ..|> AdapterMail 


' -----------------------------------------

class Tecnico {
 - nombre: String
 - apellido: String
 - documento: Documento
 - cuil: String
 - contacto: Contacto
 - areaDeCobertura: Area
}

Tecnico --> Contacto
Tecnico --> Area
Tecnico --> Documento
Tecnico --> Usuario

' -----------------------------------------

class Area {
 - coordenada: Coordenada
 - radio: double
}

' -----------------------------------------

class Mensaje {
 - asunto: String
 - cuerpo: String
 - fecha: LocalDateTime
 - destinatario: Usuario
 + registrarEnRepositorio(): void
}

' -----------------------------------------

class Contacto {
 - mediosDeContacto: Set<MedioDeContacto>
 + agregarMedioDeContacto(medioDeContacto: MedioDeContacto): void
 + quitarMedioDeContacto(medioDeContacto: MedioDeContacto): void
}

Contacto --> "*" MedioDeContacto

' -----------------------------------------

class Respuesta {
 - pregunta: Pregunta
 - contenido: String
}

Respuesta ---> Pregunta

' -----------------------------------------
interface Pregunta {
 + esValida(respuesta: String): boolean
}

class MultipleChoice {
 - campo: String
 - activa: boolean
 - opciones: Set<String>
 + esValida(respuesta: String): boolean
}

MultipleChoice ..|> Pregunta

class PreguntaAbierta {
 - campo: String
 - activa: boolean
 + esValida(respuesta: String): boolean
}

PreguntaAbierta ..|> Pregunta

' -----------------------------------------

class ReconocimientoTrabajoRealizado {
 - static coeficientes: Map<String, float>
 + calcularPuntaje(contribuciones: Set<Contribucion>, puntajeGastado: float): float
}

ReconocimientoTrabajoRealizado ..> " * " Contribucion

note bottom
Esta clase es un Singleton y los coeficientes se encuentran en un archivo de configuración.
Utilizar este patrón de diseño en este caso no afecta la testeabilidad ya que no es
necesario un mock.
end note

' -----------------------------------------

class Tarjeta {
 - codigo: String
 - historialUsos: List<UsoDeTarjeta>
 - fechaEntrega: LocalDate
 + calcularPuntaje(): float
 + agregarUso(usoTarjeta: UsoDeTarjeta): void
}

Tarjeta --> " * " UsoDeTarjeta
Tarjeta ..|> Contribucion

' -----------------------------------------

class UsoDeTarjeta {
 - fecha: LocalDateTime
 - heladera: Heladera
}

UsoDeTarjeta --> Heladera

note right
Permite trazabilidad
end note

' -----------------------------------------

class PersonaVulnerable {
 - nombre: String
 - fechaDeNacimiento: LocalDate
 - fechaDeRegistro: LocalDate
 - dirección: String
 - menoresACargo: int
 - documento: Documento
 - donanteQueLoRegistro: PersonaHumana
 + usarTarjeta(heladera: Heladera, vianda: Vianda): void
 + contarUsosHoy(): int;
}

PersonaVulnerable --> PersonaHumana
PersonaVulnerable --> Documento

' -----------------------------------------

class PersonaJuridica {
 - usuario: String
 - contacto: Contacto
 - dirección: Direccion
 - razonSocial: String
 - tipo: TipoPersonaJuridica
 - rubro: Rubro
 - contribucionesElegidas: Set<FormasContribucionJuridicas>
 - heladerasACargo: Set<Heladera>
 - contribuciones: Set<Contribucion>
 - ofertasCanjeadas: Set<OfertaCanjeada>

 + hacerseCargoDeHeladera(heladera: Heladera): void
 + darDeBajaHeladera(heladera: Heladera): void
 + agregarContribucion(contribucion: Contribucion): void
 + puntosGastados(): float
 + calcularPuntajeNeto(): float
}

PersonaJuridica --> " * " FormasContribucionJuridica
PersonaJuridica --> Rubro
PersonaJuridica --> Contacto
PersonaJuridica --> Direccion
PersonaJuridica --> " * " Heladera
PersonaJuridica --> TipoPersonaJuridica
PersonaJuridica --> Usuario

' -----------------------------------------

class Direccion {
 - calle: Calle
 - altura: String
 - municipio: Municipio 
 - provincia: Provincia
 + estaCercaDe(direccion: Direccion): boolean
 + obtenerCoordenada(): Coordenada
}

class Calle {
 - calle: String
}

Direccion --> Calle
Direccion --> Coordenada
Direccion ..> ServicioGeoRef

' -----------------------------------------

class Coordenada {
 - latitud: String
 - longitud: String
}

' -----------------------------------------

interface AdapterRecomendacionPuntosHeladera {
 + recomendacion(latitud: String, longitud: String, radio: float): Set<Coordenada>
}

AdapterRecomendacionPuntosHeladera ..> " * " Coordenada

' -----------------------------------------

enum FormasContribucionHumanas {
 DISTRIBUCION_VIANDAS
 DONACION_DINERO
 DONACION_VIANDA
 ENTREGA_TARGETAS
}

enum FormasContribucionJuridica {
 DONACION_DINERO
 ENCARGARSE_DE_HELADERA
 OFRECER_OFERTA
}

enum TipoPersonaJuridica {
 GUBERNAMENTAL
 ONG
 EMPRESA
 INSTITUCION
}

enum TipoDocumento {
 LC
 LE
 DNI
}

enum EstadoHeladera {
 FALLA_TEMPERATURA
 ACTIVA
 FRAUDE
 FALLA_CONEXION
 FALLA_TECNICA
}

' -----------------------------------------

class Usuario {
 - nombre: String
 - clave: String
 - rol: Rol
 + cambiarClave(clave: String, validador: ValidadorDeClave): void
}

Usuario --> Rol
Usuario ..> ValidadorDeClave

' -----------------------------------------

class ValidadorDeClave{
 - validadores: Set<TipoValidacion>
 + esValido(clave: String): boolean
}

ValidadorDeClave --> " * " TipoValidacion

' -----------------------------------------

interface TipoValidacion{
 + validar(clave: String): boolean
 + getMensajeError(): String
}

' -----------------------------------------

class LongitudEstipulada{
 - longitudMaxima: int
 - longitudMinima: int
 + validar(clave: String): boolean
 + getMensajeError(): String
}

LongitudEstipulada ..|> TipoValidacion

' -----------------------------------------

class ListaDePeoresClavesMemorizados{
 + validar(clave: String): boolean
 + getMensajeError(): String
}

ListaDePeoresClavesMemorizados ..|> TipoValidacion

' -----------------------------------------

class AusenciaDeCredencialesPorDefecto{
 - usuario: String
 + validar(clave: String): boolean
 + getMensajeError(): String
}

AusenciaDeCredencialesPorDefecto ..|> TipoValidacion

' -----------------------------------------

class Rol {
 - nombre: String
 - permisos: Set<Permiso>
 + tenesPermiso(permiso: Permiso): boolean
}

Rol --> " * "Permiso

' -----------------------------------------

class Permiso {
 - nombre: String
}

' -----------------------------------------

@enduml