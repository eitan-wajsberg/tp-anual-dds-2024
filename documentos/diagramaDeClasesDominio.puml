@startuml diagramaDeClasesDominio.
!theme reddress-darkblue

' -----------------------------------------

class PersonaHumana {
 - contacto: Contacto
 - direccion: Direccion
 - nombre: String
 - apellido: String
 - documento: Documento
 - fechaNacimiento: LocalDate
 - tarjeta: Tarjeta
 - ofertasCanjeadas: List<OfertaCanjeada>
 - contribucionesElegidas: Set<FormasContribucionHumanas>
 - contribuciones: Set<Contribucion>
 - ofertasCanjeadas: Set<OfertaCanjeada>
 - formulario: List<Respuesta>

 + puntosGastados(): float
 + calcularPuntajeNeto(): float
 + agregarContribucion(contribucion: Contribucion): void
 + agregarOfertaCanjeada(ofertaCanjeada: OfertaCanjeada): void
 + usarTarjeta(heladera: Heladera): void
 + asignarTarjeta(tarjeta: Tarjeta): void
 + serNotificadoPor(mensaje: Mensaje): void
}

PersonaHumana --> " * " Contribucion
PersonaHumana --> Contacto
PersonaHumana --> Direccion
PersonaHumana --> Documento
PersonaHumana --> " * " FormasContribucionHumanas
PersonaHumana --> Usuario
PersonaHumana --> " * " OfertaCanjeada
PersonaHumana --> " * " Respuesta
PersonaHumana --> Tarjeta
PersonaHumana ..|> IObserverNotificacion 

' -----------------------------------------

interface IObserverNotificacion {
 + serNotificadoPor(mensaje: Mensaje): void
}

' -----------------------------------------

class Vianda {
 - fechaCaducidad: LocalDate
 - entregada: boolean
 - comida: String
 - pesoEnGramos: float
 - fechaDonacion: LocalDate
 + calcularPuntaje(): float
 + estaVencida(): boolean
}

Vianda ..|> Contribucion

' -----------------------------------------

class Heladera {
 - id: Long
 - nombre: String
 - direccion: Direccion
 - fechaRegistro: LocalDate
 - capacidadMaximaViandas: int
 - modelo: Modelo
 - viandas: Set<Vianda>
 - estado: EstadoHeladera
 - temperaturaEsperada: float
 - historialEstados: List<CambioEstado>
 - historialTemperaturas: List<CambioTemperatura>
 - solicitudesDeApertura: List<SolicitudApertura>
 + ingresarViandas(viandas: List<Vianda>): void
 + quitarViandas(viandas: List<Vianda>): void
 + notificarColaborador(): void
 + calcularPuntaje(): float
 + cambiarEstado(nuevoEstado: CambioEstado): void
 - tieneTemperaturaValida(): boolean
 + cambiarTemperatura(temperatura: float): void
 - agregarTemperaturaAlHistorial(temperatura: float): void
 + estaActiva(): boolean
 + validarApertura(codigoTarjeta: String): boolean
 + agregarSolicitudApertura(solicitud: SolicitudApertura): void
 + cantidadViandas(): int
 + cantidadViandasVirtuales(): int
 + enviarAHeladeraFisicaSolicitudApertura(): void
}

Heladera --> " * " Vianda
Heladera --> Modelo
Heladera --> Direccion
Heladera ..|> Contribucion
Heladera --> EstadoHeladera
Heladera --> " * " CambioEstado
Heladera --> " * " CambioTemperatura
Heladera --> " * " SolicitudApertura

' -----------------------------------------

class ValidadorConexion {
 - umbralDesconexionEnMinutos: int
 - heladerasRepositorio: IRepositoryHeladera
 + verificarConexionHeladeras(): void
 - estaConectada(heladera: Heladera): boolean
}

ValidadorConexion ..> Heladera

note right
La falla de conexión se verificará validando la última recepción de temperatura de cada heladera con un cronjob: ValidadorConexion.
La cantidad de tiempo límite desde que se recibió la última temperatura estará parametrizada.
end note

' -----------------------------------------

class GestorSuscripciones {
  - suscripcionesPorTipo: Map<TipoSuscripcion, Map<Integer, List<Suscripcion>>>

  + notificar(cantidadViandas: int, tipo: TipoSuscripcion, heladera: Heladera): void
  + suscribirPersona(persona: PersonaHumana, tipoSuscripcion: TipoSuscripcion, cantidadViandas: int, heladera: Heladera): void
  + suscribirPersona(persona: PersonaHumana, heladera: Heladera): void
  + suscripcionValida(persona: PersonaHumana, heladera: Heladera): boolean
}

GestorSuscripciones --> " * " Suscripcion
GestorSuscripciones --> " * " TipoSuscripcion

enum TipoSuscripcion {
 FALTAN_N_VIANDAS
 DESPERFECTO
 QUEDAN_N_VIANDAS
}

class Suscripcion {
 - colaborador: PersonaHumana
 + notificar(heladera: Heladera): void
   /'
   if(cumpleCondicion(heladera)){
      Mensaje mensaje = armarMensaje(heladera);
      this.colaborador.serNotificadoPor(mensaje);
      mensaje.registrar();
   }'/
 - armarMensaje(heladera: Heladera): Mensaje
 # cumpleCondicion(heladera: Heladera): boolean
 # armarCuerpo(heladera: Heladera): String
}

note bottom
Utilizamos el patron Template, ya que todas las suscripciones
tienen comportamiento en comun, el armado del mensaje y la notificacion
para todas es el mismo, solo cambian las condiciones y el cuerpo del mensaje
de las mismas.
end note

Suscripcion --> PersonaHumana
Suscripcion ..> Heladera

class QuedanNViandas {
 - cantidadViandasDisponibles: int
 # cumpleCondicion(heladera: Heladera): void
 # armarCuerpo(heladera: Heladera): String
}

class FaltanNViandas {
 - cantidadViandasParaLlenarse: int
 # cumpleCondicion(heladera: Heladera): void
 # armarCuerpo(heladera: Heladera): String
}

class Desperfecto {
 - aceptada: boolean
 + sugerirHeladeras(heladera: Heladera): String
 # cumpleCondicion(heladera: Heladera): void
 # armarCuerpo(heladera: Heladera): String
}

QuedanNViandas --|> Suscripcion
FaltanNViandas --|> Suscripcion
Desperfecto --|> Suscripcion

' -----------------------------------------

interface IAdapterPDF {
 + exportarAPDF(titulo: String, parrafos: List<String>): void
}

class AdapterPDFiText {
 + iText: ITextPDF
 + exportarAPDF(titulo: String, parrafos: List<String>): void
}

AdapterPDFiText --> ITextPDF

class ITextPDF {
 + ruta: String
 + generarPDF(titulo: String, parrafos: List<String>);
}

AdapterPDFiText ..|> IAdapterPDF

class GeneradorReportes {
 - reportes: List<Reporte>
 - pdfAPI: IAdapterPDF
 - temporalidad: Temporalidad
 + generarReportes(): void
 + calcularFechaInicio: LocalDate
 + agregarReporte(reporte: Reporte): void
 + quitarReporte(reporte: Reporte): void
}

GeneradorReportes --> " * " Reporte
GeneradorReportes --> IAdapterPDF
GeneradorReportes --> Temporalidad

enum Temporalidad {
 DIARIO
 SEMANAL
 MENSUAL
 ANUAL
}

interface Reporte {
 + generarReporte(fechaInicio: LocalDate, fechaFin: LocalDate): List<String>
 + titulo(): String
}

class CantidadDeFallasPorHeladera {
 - repositorioHeladera: IRepositorioHeladera
 + generarReporte(fechaInicio: LocalDate, fechaFin: LocalDate): List<String>
 + titulo(): String
 - cantidadFallas(heladera: Heladera, fechaInicio: LocalDate, fechaFin: LocalDate): int
}

CantidadDeFallasPorHeladera ..|> Reporte
CantidadDeFallasPorHeladera ..> Heladera

class MovimientoViandasPorHeladera {
 - repositorioHeladera: IRepositorioHeladera
 + generarReporte(fechaInicio: LocalDate, fechaFin: LocalDate): List<String>
 + titulo(): String
 - cantidadViandasSegunAccion(heladera: Heladera, accion: AccionApertura, fechaInicio: LocalDate, fechaFin: LocalDate): int
}

MovimientoViandasPorHeladera ..|> Reporte
MovimientoViandasPorHeladera ..> Heladera
MovimientoViandasPorHeladera ..> AccionApertura

class CantidadViandasPorColaborador {
 - repositorioColaboradores: IRepositorioPersonaHumana
 + generarReporte(fechaInicio: LocalDate, fechaFin: LocalDate): List<String>
 + titulo(): String
 - cantidadViandasDonadadas(persona: PersonaHumana, fechaInicio: LocalDate, fechaFin: LocalDate): int
}

CantidadViandasPorColaborador ..|> Reporte
CantidadViandasPorColaborador ..> PersonaHumana

' -----------------------------------------

class SolicitudApertura {
 - fecha: LocalDateTime
 - codigoTarjeta: String 
 - aperturaConcretada: boolean
 - accion: AccionApertura
}

SolicitudApertura --> AccionApertura

enum AccionApertura {
 QUITAR_VIANDA
 INGRESAR_VIANDA
}
' -----------------------------------------

class CambioEstado {
 - fechaCambio: LocalDate
 - estado: EstadoHeladera
 + esUnaFalla(): boolean
}

CambioEstado --> EstadoHeladera

note bottom
Permite trazabilidad
end note

' -----------------------------------------

class Incidente {
 - heladera: Heladera
 - fecha: LocalDateTime
 - tecnico: Tecnico
 - visitas: List<Visita>
 - solucionado: bool
 - tipoIncidente: TipoIncidente
 + registrarVisita(visita: Visita): void
 + asignarTecnico(): void
 /'
 float distanciaMasCorta; Tecnico tecnico; float distanciaActual;
 for cada tecnico
   for cada tecnico.areaDeCobertura
      distanciaActual = heladera.getDireccion().getCoordenada().distanciaCon(area.getCoordenada())
      if distanciaActual < distanciaMasCorta{
         distanciaMasCorta = distanciaActual
         tecnico = tecnico

   tecnico.getMedioDeContacto().notificar(new Mensaje("heladera"+...+tipoIncidente.obtenerDescripcionIncidente()))
   '/
}

Incidente --> TipoIncidente
Incidente --> " * " Visita
Incidente --> Tecnico

interface TipoIncidente {
 + obtenerDescripcionIncidente(): String
} 

class Visita {
 - descripcion: String
 - foto: Image
}

class Alerta {
 - incidente: Incidente
 - tipo: TipoAlerta
 + obtenerDescripcionIncidente(): String
}

Alerta ..|> TipoIncidente
Alerta --> TipoAlerta

class FallaTecnica {
 - incidente: Incidente
 - colaborador: 
 - descripcion: String
 - foto: Image
 + obtenerDescripcionIncidente(): String
}

FallaTecnica ..|> TipoIncidente

enum TipoAlerta {
 FRAUDE
 FALLA_CONEXION
 FALLA_TEMPERATURA
}

' -----------------------------------------

class ServicioGeoRef {
 - instancia: ServicioGeoRef
 - retrofit: Retrofit
 + obtenerDetallesUbicacion(latitud: double, longitud: double): Direccion
}

' -----------------------------------------
class ReceptorTemperatura {
    - client: MqttClient
    - repositorioHeladeras: RepositorioHeladera

    + subscribe(topic: String): void
    + connectionLost(cause: Throwable): void
    + messageArrived(topic: String, mqttMessage: MqttMessage): void
    - dividirPayload(payload: String): String[]
    - procesarMensaje(idHeladera: Long, tipoMensaje: String, valor: int): void
}

class ReceptorMovimiento {
    - repositorioHeladeras: RepositorioHeladera
    + messageArrived(topic: String, mensaje: MqttMessage): void
    - dividirPayload(payload: String): String[]
    - procesarMensaje(idHeladera: Long, tipoMensaje: String, valor: Boolean): void
}

' VERIFICAR!!!!! estan bien estas relaciones?
ReceptorMovimiento ..> Heladera
ReceptorTemperatura ..> Heladera

' -----------------------------------------

class CambioTemperatura {
 - fecha: LocalDateTime
 - temperaturaCelsius: float
}

' -----------------------------------------

class CargaMasivaColaboraciones {
 - personaHumanaRepo: IRepositorioPersonaHumana
 - documentoRepo: IRepositorioDocumento
 - adapterMail: AdapterMail
 + cargarColaboraciones(dataCSV: File): void
}

CargaMasivaColaboraciones --> AdapterMail

' -----------------------------------------

class Modelo {
 - modelo: String
 - temperaturaMinima: float
 - temperaturaMaxima: float
}

' -----------------------------------------

class DistribucionVianda {
 - heladeraOrigen: Heladera
 - heladeraDestino: Heladera
 - cantidadViandas: int
 - motivo: String
 - fecha: LocalDate
 - terminada: bool
 - viandasAMover: List<Vianda>
 + quitarViandasDeOrigen(viandasAQuitar: List<Vianda>): void
 /'{
      origen.quitarViandas(viandasAQuitar)
      viandasAMover = viandasAQuitar
   }'/
 + ponerViandasEnDestino():void
 /' {
      destino.meterViandas(viandasAMover)
   }'/
 + distribuir(viandas: List<Vianda>): void
 + calcularPuntaje(): float
}

DistribucionVianda --> Heladera
DistribucionVianda --> Heladera
DistribucionVianda ..> " * " Vianda
DistribucionVianda ..|> Contribucion

' -----------------------------------------

interface Contribucion {
 + calcularPuntaje(): float
 + obtenerTipoContribucion(): TipoContribucion
 + obtenerFechaRegistro(): LocalDate
}

Contribucion ..> TipoContribucion

enum TipoContribucion {
 DISTRIBUCION_VIANDAS
 DONACION_DINERO
 DONACION_VIANDA
 ENTREGA_TARJETAS
 ENCARGARSE_DE_HELADERA
 OFRECER_OFERTA
}

note bottom
Las contribuciones comparten la funcionalidad de sumar puntos, por lo
tanto, decidimos que implementen una interfaz de contribución y de esta
forma agrupar las contribuciones, permitiendo trazabilidad.
end note

' -----------------------------------------

class DonacionDinero {
 - monto: float
 - frecuencia: Integer
 - unidadFrecuencia: String
 - fecha: LocalDate
 + calcularPuntaje(): float
}

DonacionDinero ..|> Contribucion

note bottom
unidadFrecuencia podría tener los valores:
 - Semanal
 - Mensual
 - Anual
end note

' -----------------------------------------

class Oferta {
 - nombre: String
 - cantidadPuntosNecesarios: float
 - imagen: ???
 - rubro: Rubro
 - organizacion: PersonaJuridica
 + canjear(): void
}

Oferta --> PersonaJuridica
Oferta --> Rubro

class OfertaCanjeada {
 - oferta: Oferta
 - fechaCanje: LocalDateTime
}

OfertaCanjeada --> Oferta


' -----------------------------------------

class Rubro {
 - nombre: String
}

' -----------------------------------------

class Documento {
 - tipo: TipoDocumento
 - documento: String
}

Documento --> TipoDocumento

' -----------------------------------------

interface MedioDeContacto {
 + enviar(mensaje: Mensaje)
}

MedioDeContacto ..> Mensaje

' -----------------------------------------

class WhatsApp {
 - numero: String
 + enviar(mensaje: Mensaje)
}

WhatsApp ..|> MedioDeContacto

' -----------------------------------------

class Telefono {
 - numero: String
 + enviar(mensaje: Mensaje)
}

Telefono ..|> MedioDeContacto

' -----------------------------------------

class Mail {
 - correo: String
 - adapterMail: AdapterMail
 + enviar(mensaje: Mensaje)
}

Mail ..|> MedioDeContacto
Mail -> AdapterMail

' -----------------------------------------

interface AdapterMail {
 + enviar(mensaje: Mensaje, correo: String)
}

AdapterMail ..> Mensaje

note bottom
Utilizamos un adapter para tener mayor testeabilidad,
mantenibilidad y un menor acoplamiento
end note

' -----------------------------------------

class AdapterConcretoPuntos {
 - servicioRecomendacionPunto: RecomendacionPuntosServicio
 + recomendacion(latitud: String, longitud: String, radio: float): List<Coordenada>
}

note top
Por mantenibilidad, cohesion y testeabilidad utilizamos el patron
adapter.
end note

AdapterConcretoPuntos ..|> AdapterRecomendacionPuntosHeladera
AdapterConcretoPuntos --> RecomendacionPuntosServicio

' -----------------------------------------

class RecomendacionPuntosServicio {
 - urlAPI: String
 - retrofit: Retrofit
 + listadoPuntosRecomendados(float radio, String latitud, String longitud): ListadoPuntosRecomendados
}

RecomendacionPuntosServicio ..> ListadoPuntosRecomendados

' -----------------------------------------

class ListadoPuntosRecomendados {
 - parametro: Area
 + puntos: List<Coordenada>
}

ListadoPuntosRecomendados --> Area
ListadoPuntosRecomendados --> " * " Coordenada

' -----------------------------------------

class RecomendacionDePuntos {
 - adapterPuntos: AdapterRecomendacionPuntosHeladera
 + recomendacion(latitud: String, longitud: String, radio: float): List<Coordenada>
}

RecomendacionDePuntos --> AdapterRecomendacionPuntosHeladera

' -----------------------------------------

class MailSender {
 + enviar(mensaje: Mensaje, destinatario: String)
}

MailSender ..|> AdapterMail 


' -----------------------------------------

class Tecnico {
 - nombre: String
 - apellido: String
 - documento: Documento
 - cuil: String
 - contacto: Contacto
 - areaDeCobertura: Area
}

Tecnico --> Contacto
Tecnico --> Area
Tecnico --> Documento
Tecnico --> Usuario

' -----------------------------------------

class Area {
 - coordenada: Coordenada
 - radio: double
}

' -----------------------------------------

class Mensaje {
 - asunto: String
 - cuerpo: String
 - fecha: LocalDateTime
 - destinatario: Usuario
 + registrarEnRepositorio(): void
}

' -----------------------------------------

class Contacto {
 - mediosDeContacto: Set<MedioDeContacto>
 + agregarMedioDeContacto(medioDeContacto: MedioDeContacto): void
 + quitarMedioDeContacto(medioDeContacto: MedioDeContacto): void
 + enviarMensaje(Mensaje mensaje): void
}

Contacto --> "*" MedioDeContacto

' -----------------------------------------

class Respuesta {
 - pregunta: Pregunta
 - contenido: String
}

Respuesta ---> Pregunta

' -----------------------------------------
interface Pregunta {
 + esValida(respuesta: String): boolean
}

class MultipleChoice {
 - campo: String
 - activa: boolean
 - opciones: Set<String>
 + esValida(respuesta: String): boolean
}

MultipleChoice ..|> Pregunta

class PreguntaAbierta {
 - campo: String
 - activa: boolean
 + esValida(respuesta: String): boolean
}

PreguntaAbierta ..|> Pregunta

' -----------------------------------------

class ReconocimientoTrabajoRealizado {
 - static coeficientes: Map<String, float>
 + calcularPuntaje(contribuciones: Set<Contribucion>, puntajeGastado: float): float
}

ReconocimientoTrabajoRealizado ..> " * " Contribucion

note bottom
Esta clase es un Singleton y los coeficientes se encuentran en un archivo de configuración.
Utilizar este patrón de diseño en este caso no afecta la testeabilidad ya que no es
necesario un mock.
end note

' -----------------------------------------

class Tarjeta {
 - codigo: String
 - historialUsos: List<UsoDeTarjeta>
 - fechaEntrega: LocalDate
 + calcularPuntaje(): float
 + agregarUso(usoTarjeta: UsoDeTarjeta): void
 + cantidadDeUsos(dia: LocalDate): int
}

Tarjeta --> " * " UsoDeTarjeta
Tarjeta ..|> Contribucion

' -----------------------------------------

class UsoDeTarjeta {
 - fecha: LocalDateTime
 - heladera: Heladera
}

UsoDeTarjeta --> Heladera

note right
Permite trazabilidad
end note

' -----------------------------------------

class PersonaVulnerable {
 - nombre: String
 - fechaDeNacimiento: LocalDate
 - fechaDeRegistro: LocalDate
 - dirección: String
 - menoresACargo: int
 - documento: Documento
 - donanteQueLoRegistro: PersonaHumana
 + usarTarjeta(heladera: Heladera, vianda: Vianda): void
}

PersonaVulnerable --> PersonaHumana
PersonaVulnerable --> Documento

' -----------------------------------------

class PersonaJuridica {
 - usuario: String
 - contacto: Contacto
 - dirección: Direccion
 - razonSocial: String
 - tipo: TipoPersonaJuridica
 - rubro: Rubro
 - contribucionesElegidas: Set<FormasContribucionJuridicas>
 - heladerasACargo: Set<Heladera>
 - contribuciones: Set<Contribucion>
 - ofertasCanjeadas: Set<OfertaCanjeada>

 + hacerseCargoDeHeladera(heladera: Heladera): void
 + darDeBajaHeladera(heladera: Heladera): void
 + agregarContribucion(contribucion: Contribucion): void
 + puntosGastados(): float
 + calcularPuntajeNeto(): float
}

PersonaJuridica --> " * " FormasContribucionJuridica
PersonaJuridica --> Rubro
PersonaJuridica --> Contacto
PersonaJuridica --> Direccion
PersonaJuridica --> " * " Heladera
PersonaJuridica --> TipoPersonaJuridica
PersonaJuridica --> Usuario

' -----------------------------------------

class Direccion {
 - calle: Calle
 - altura: String
 - municipio: Municipio 
 - provincia: Provincia
 + estaCercaDe(direccion: Direccion): boolean
 + obtenerCoordenada(): Coordenada
}

class Calle {
 - calle: String
}

class Municipio {
 - municipio: String
}

class Provincia {
 - provincia: String
}

Direccion --> Calle
Direccion --> Municipio
Direccion --> Provincia
Direccion --> Coordenada
Direccion ..> ServicioGeoRef

' -----------------------------------------

class Coordenada {
 - latitud: String
 - longitud: String
}

' -----------------------------------------

interface AdapterRecomendacionPuntosHeladera {
 + recomendacion(latitud: String, longitud: String, radio: float): Set<Coordenada>
}

AdapterRecomendacionPuntosHeladera ..> " * " Coordenada

' -----------------------------------------

enum FormasContribucionHumanas {
 DISTRIBUCION_VIANDAS
 DONACION_DINERO
 DONACION_VIANDA
 ENTREGA_TARGETAS
}

enum FormasContribucionJuridica {
 DONACION_DINERO
 ENCARGARSE_DE_HELADERA
 OFRECER_OFERTA
}

enum TipoPersonaJuridica {
 GUBERNAMENTAL
 ONG
 EMPRESA
 INSTITUCION
}

enum TipoDocumento {
 LC
 LE
 DNI
}

enum EstadoHeladera {
 FALLA_TEMPERATURA
 ACTIVA
 FRAUDE
 FALLA_CONEXION
 FALLA_TECNICA
}

' -----------------------------------------

class Usuario {
 - nombre: String
 - clave: String
 - rol: Rol
 + cambiarClave(clave: String, validador: ValidadorDeClave): void
}

Usuario --> Rol
Usuario ..> ValidadorDeClave

' -----------------------------------------

class ValidadorDeClave{
 - validadores: Set<TipoValidacion>
 + esValido(clave: String): boolean
}

ValidadorDeClave --> " * " TipoValidacion

' -----------------------------------------

interface TipoValidacion{
 + validar(clave: String): boolean
 + getMensajeError(): String
}

' -----------------------------------------

class LongitudEstipulada{
 - longitudMaxima: int
 - longitudMinima: int
 + validar(clave: String): boolean
 + getMensajeError(): String
}

LongitudEstipulada ..|> TipoValidacion

' -----------------------------------------

class ListaDePeoresClavesMemorizados{
 + validar(clave: String): boolean
 + getMensajeError(): String
}

ListaDePeoresClavesMemorizados ..|> TipoValidacion

' -----------------------------------------

class AusenciaDeCredencialesPorDefecto{
 - usuario: String
 + validar(clave: String): boolean
 + getMensajeError(): String
}

AusenciaDeCredencialesPorDefecto ..|> TipoValidacion

' -----------------------------------------

class Rol {
 - nombre: String
 - permisos: Set<Permiso>
 + tenesPermiso(permiso: Permiso): boolean
}

Rol --> " * "Permiso

' -----------------------------------------

class Permiso {
 - nombre: String
}

' -----------------------------------------

@enduml